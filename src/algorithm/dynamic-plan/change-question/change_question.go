package change_question

/*
  问题描述。给定某不超过100万元的现金总额，兑换成数量不限的100、50、20、10、5、2、1元的纸币组合，共有多少种组合？
  思路：此问题涉及两个类别：面值和总额。所以我们定义dp[i][j]表示使用小于等于i的纸币，凑成j元钱，共有多少种组合方法。比如dp[100][500]表示使用面值不大于100的纸币，凑出500块钱，共有多少种组合方法。
  进一步思考，如果面值都是1元的，则无论总额多少，可行的组合数都为1.比如只用1元的纸币凑出100元，显然只有一种组合方法。那么如果多出一种面值呢？组合数有什么变化？
  回到dp[100][500]，既然用小于等于100的纸币凑出500块钱，则组合中只会要么包含至少一张100块的纸币，要么不包含100块的纸币。所以我们可以分成两种情况考虑：
    1）如果没有包括100元，则用到的最大面值可能为50元，即使用面值小于等于50的纸币，凑出500块钱，表示形式为：dp[50][500];
    2）如果必须包含100元，怎么计算呢？既然至少包含100元，我们先拿出100块钱，则还需要凑出400块钱即可完成。用小于或等于100元的纸币凑出400块钱，表示形式为dp[100][400];
  将两者综合起来为：dp[100][500] = dp[50][500] + dp[100][400];
  为了方便表示，我们定义纸币面值为一个数组：dom[] = {1,2,5,10,20,50,100},这样dom[i]和dom[i-1]就表示相邻的纸币面额了。i的意义从面值变成了面值下标。
  根据上面分析，对于一般情况，我们有dp[i][j] = dp[i-1][j] + dp[i][j-dom[i]]. ]有了一般情况，在考虑两种特殊情况：
  如果dp[i][0]应该返回啥？dp[i][0]表示用小于等于i的纸币，凑出0块钱，我们可以定义这种情况的值为1；
  如果dp[0][j]应该返回啥？dp[0][j]表示用小于等于0的纸币，凑出j块钱，我们可以定义这种情况的值为1.
  再看dp[100][78]，用小于等于100元的纸币凑出78块钱，这时组合中一定不会包含100块的纸币，因此dp[100][78] = dp[50][78],即当j < dom[i]时，dp[i][j] = dp[i-1][j]。
 */
//
/* 方程:
    dom[] = {1,2,5,10,20,50,100}
    dp[i][j] = dp[i-1][j] + dp[i][j-dom[i]], j>=dom[i]
    dp[i][j] = dp[i-1][j],  j<dom[i]
 */
func Change(dom []int, total int) int {
	row, col := len(dom), total+1
	dp := make([][]int, len(dom))
	for j := 0; j < col; j++ {
		dp[0][j] = 1 // 表示用1块钱凑出任何金额的组合数都为1
	}

	for i := 1; i < row; i++ {
		dp[i][0] = 1
		for j := 1; j < col; j++ {
			if j < dom[i] { // 表示要凑出的金额数小于当前的纸币面额，如dp[100][87] = dp[50][87]
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = dp[i-1][j] + dp[i][j-dom[i]]
			}
		}
	}
	return dp[row-1][col-1]
}
